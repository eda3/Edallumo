diff --git a/src/commands/frames/meter.rs b/src/commands/frames/meter.rs
index 8684e11..3389ec9 100644
--- a/src/commands/frames/meter.rs
+++ b/src/commands/frames/meter.rs
@@ -1,296 +1,307 @@
-use crate::{check, find, Context, Error, ImageLinks, MoveInfo, EMBED_COLOR, IMAGE_DEFAULT};
-use colored::Colorize;
-use poise::serenity_prelude::CreateEmbed;
-use std::{fs, string::String};
-
-const GREEN_CIRCLE: &str = "🟢\u{200b}";
-const RED_SQUARE: &str = "🟥\u{200b}";
-const BLUE_DIAMOND: &str = "🔷\u{200b}";
-
-// Returns a String of symbols representing startup frames
+//! meter.rs
+//! ファイル全体説明コメント
+//! フレームメーター表示機能全体
+//! 開始・アクティブ・リカバリーフレーム情報処理
+//! コマンド実行機能
+
+use crate::{check, find, Context, Error, ImageLinks, MoveInfo, EMBED_COLOR, IMAGE_DEFAULT}; // 依存モジュール群
+use colored::Colorize; // 文字色変換ライブラリ
+use poise::serenity_prelude::CreateEmbed; // 埋め込み作成ライブラリ
+use std::{fs, string::String}; // ファイル操作・文字列操作
+
+const GREEN_CIRCLE: &str = "🟢\u{200b}"; // 緑丸定数
+const RED_SQUARE: &str = "🟥\u{200b}"; // 赤四角定数
+const BLUE_DIAMOND: &str = "🔷\u{200b}"; // 青菱形定数
+
+/// 指定ムーブの開始フレーム情報からシンボル文字列生成
+///
+/// # 引数
+/// * `move_info` - ムーブ情報構造体参照
+///
+/// # 戻り値
+/// 開始フレームシンボル文字列
 async fn startup_frames(move_info: &MoveInfo) -> String {
-    let startup_vec = sep_frame_vec(&move_info.startup).await;
-    let mut meter_msg = String::new();
-    //println!("startup_vec: {:?}", startup_vec);
+    let startup_vec = sep_frame_vec(&move_info.startup).await; // 開始フレーム分割結果取得
+    let mut meter_msg = String::new(); // メーター文字列初期化
+                                       // println!("startup_vec: {:?}", startup_vec); // デバッグ出力用
 
-    // If vec has only one entry and the entry is empty or -
-    // If vec has only one entry and the move has only 1 frame of startup
+    // 単一エントリかつ空または "-"、または1フレームのみの場合
     if (startup_vec.len() == 1 && startup_vec[0] == "-")
         || (startup_vec.len() == 1 && startup_vec[0].parse::<u16>().unwrap() == 1)
     {
-        meter_msg += "-";
+        meter_msg += "-"; // 単一フレーム表現
     }
-    // Otherwise execute logic
+    // 複数エントリの場合の処理
     else {
-        // This bool to determine if bracket was present
-        let mut startup_bra = false;
+        let mut startup_bra = false; // 括弧有無判定フラグ初期化
 
-        // Making the message
+        // 各エントリ処理ループ
         for x in 0..startup_vec.len() {
-            // If vec string entry is a digit
+            // 数字エントリの場合
             if let Ok(num) = startup_vec[x].parse::<u16>() {
-                // Iterate up to its numerical value -1
+                // 数値-1回分ループ処理
                 for _ in 0..num - 1 {
-                    // If left bracket was not passed previously
                     if !startup_bra {
-                        // Put a GREEN_CIRCLE into the message
-                        meter_msg += GREEN_CIRCLE;
-                    }
-                    // If left bracket was passed
-                    else {
-                        // The difference between the first possible frame a move can connect
-                        // and the latest frame -1 is the times a GREEN_CIRCLE is going to be
-                        // put inside the msg and inside brackets
+                        meter_msg += GREEN_CIRCLE; // 括弧前：緑丸追加
+                    } else {
+                        // 括弧内：前エントリとの差分回数緑丸追加
                         for _ in 0..((startup_vec[x].parse::<u16>().unwrap())
                             - (startup_vec[x - 2].parse::<u16>()).unwrap())
                         {
-                            meter_msg += GREEN_CIRCLE;
+                            meter_msg += GREEN_CIRCLE; // 括弧内緑丸追加
                         }
-                        break;
+                        break; // ループ中断
                     }
                 }
             }
-            // If vec string entry isnt a digit
+            // 数字以外のエントリの場合
             else {
-                // Display a GREEN_CIRCLE if "+" is the last frame of the move
+                // "+"記号処理（末尾直前の場合）
                 if x == startup_vec.len() - 2 && startup_vec[x] == "+" {
-                    // If entry after + is a digit assert its value
                     if let Ok(num) = startup_vec[x + 1].parse::<u16>() {
-                        // If value is 1 then print GREEN_CIRCLE instead of "+"
+                        // 数字変換試行
                         if num == 1 {
-                            meter_msg += GREEN_CIRCLE;
-                        }
-                        // Otherwise put GREEN_CIRCLE and  "+" sign
-                        else {
+                            meter_msg += GREEN_CIRCLE; // 単一数値：緑丸置換
+                        } else {
                             meter_msg = meter_msg + GREEN_CIRCLE + &startup_vec[x];
+                            // 複数数値：緑丸＋"+"追加
                         }
-                    }
-                    // If entry after + isnt a number ????
-                    else {
-                        meter_msg = meter_msg + &startup_vec[x];
+                    } else {
+                        meter_msg = meter_msg + &startup_vec[x]; // 数字変換失敗：記号そのまま追加
                     }
                 }
-                // Otherwise display the symbol
+                // その他の記号処理
                 else {
-                    //println!("Indide else: {:?}", startup_vec);
-                    meter_msg = meter_msg + &startup_vec[x];
+                    meter_msg = meter_msg + &startup_vec[x]; // 記号追加
                 }
 
-                // Execute same logic for [ and ~
+                // 括弧・チルダ判定更新
                 if startup_vec[x] == "[" || startup_vec[x] == "~" {
-                    startup_bra = true;
+                    startup_bra = true; // 括弧開始
                 } else if startup_vec[x] == "]" {
-                    startup_bra = false;
+                    startup_bra = false; // 括弧終了
                 }
             }
         }
     }
-    meter_msg
+    meter_msg // シンボル文字列返却
 }
 
-// Returns a String of symbols representing active frames
+/// 指定ムーブのアクティブフレーム情報からシンボル文字列生成
+///
+/// # 引数
+/// * `move_info` - ムーブ情報構造体参照
+///
+/// # 戻り値
+/// アクティブフレームシンボル文字列
 async fn active_frames(move_info: &MoveInfo) -> String {
-    // Processing for active frames
-    let active_vec = sep_frame_vec(&move_info.active).await;
-    let mut meter_msg = String::new();
-    //println!("Active vec: {:?}", active_vec);
+    let active_vec = sep_frame_vec(&move_info.active).await; // アクティブフレーム分割結果取得
+    let mut meter_msg = String::new(); // メーター文字列初期化
+                                       // println!("Active vec: {:?}", active_vec); // デバッグ出力用
 
     if active_vec.len() == 1 && active_vec[0] == "-" {
-        meter_msg += "-";
+        meter_msg += "-"; // 単一ハイフン表現
     } else {
-        let mut hit_recovery = false;
+        let mut hit_recovery = false; // 括弧有無判定フラグ初期化
 
+        // 各エントリ処理ループ（参照）
         for active_vec_string in &active_vec {
-            // If vec string entry is a digit
             if let Ok(num) = active_vec_string.parse::<u16>() {
-                // Iterate up to its numerical value
+                // 数値エントリの場合、数値分ループ
                 for _ in 0..num {
-                    // If left parenthesis was not passed when iterating
                     if !hit_recovery {
-                        meter_msg += RED_SQUARE;
-                    }
-                    // If left parenthesis was passed when iterating
-                    else {
-                        meter_msg += BLUE_DIAMOND;
+                        meter_msg += RED_SQUARE; // 括弧前：赤四角追加
+                    } else {
+                        meter_msg += BLUE_DIAMOND; // 括弧内：青菱形追加
                     }
                 }
             }
-            // If vec string entry isnt a digit
+            // 数値以外のエントリの場合
             else {
-                meter_msg = meter_msg + active_vec_string;
-
+                meter_msg = meter_msg + active_vec_string; // 記号追加
                 if active_vec_string == "(" {
-                    hit_recovery = true;
+                    hit_recovery = true; // 括弧開始
                 } else if active_vec_string == ")" {
-                    hit_recovery = false;
+                    hit_recovery = false; // 括弧終了
                 }
             }
         }
     }
-    meter_msg
+    meter_msg // シンボル文字列返却
 }
 
-// Returns a String of symbols representing recovery frames
+/// 指定ムーブのリカバリーフレーム情報からシンボル文字列生成
+///
+/// # 引数
+/// * `move_info` - ムーブ情報構造体参照
+///
+/// # 戻り値
+/// リカバリーフレームシンボル文字列
 async fn recovery_frames(move_info: &MoveInfo) -> String {
-    // Processing for recovery frames
-    let recovery_vec = sep_frame_vec(&move_info.recovery).await;
-    let mut meter_msg = String::new();
+    let recovery_vec = sep_frame_vec(&move_info.recovery).await; // リカバリーフレーム分割結果取得
+    let mut meter_msg = String::new(); // メーター文字列初期化
 
     if recovery_vec.len() == 1 && recovery_vec[0] == "-" {
-        meter_msg += "-";
+        meter_msg += "-"; // 単一ハイフン表現
     } else {
-        let mut recovery_tilde = false;
+        let mut recovery_tilde = false; // チルダ有無判定フラグ初期化
 
+        // 各エントリ処理ループ（添字利用）
         for x in 0..recovery_vec.len() {
-            // If vec string entry is a digit
             if let Ok(num) = recovery_vec[x].parse::<u16>() {
-                // Iterate up to its numerical value
+                // 数値エントリの場合、数値分ループ
                 for _ in 0..num {
-                    // If tilde was not passed previously
                     if !recovery_tilde {
-                        // Put a BLUE_DIAMOND into the message
-                        meter_msg += BLUE_DIAMOND;
+                        meter_msg += BLUE_DIAMOND; // チルダ前：青菱形追加
                     } else {
-                        // If tilde was passed
-                        // The difference between the first possible frame a move can connect
-                        // and the latest frame -1 is the times a BLUE_DIAMOND is going to be
-                        // put inside the msg
+                        // チルダ内：前エントリとの差分回数青菱形追加
                         for _ in 0..((recovery_vec[x].parse::<u16>().unwrap())
                             - (recovery_vec[x - 2].parse::<u16>()).unwrap())
                         {
-                            meter_msg += BLUE_DIAMOND;
+                            meter_msg += BLUE_DIAMOND; // チルダ内青菱形追加
                         }
-                        break;
+                        break; // ループ中断
                     }
                 }
             }
-            // If vec string entry isnt a digit
+            // 数値以外のエントリの場合
             else {
-                meter_msg = meter_msg + &recovery_vec[x];
-                // Execute same logic for ( and ~
+                meter_msg = meter_msg + &recovery_vec[x]; // 記号追加
+                                                          // チルダ・括弧判定更新
                 recovery_tilde = recovery_vec[x] == "~" || recovery_vec[x] == "(";
             }
         }
     }
-    meter_msg
+    meter_msg // シンボル文字列返却
 }
 
-/// Splits the string into a vec keeping the separators
+/// 指定文字列を分割しセパレータを保持したベクター返却
+///
+/// # 引数
+/// * `text` - 分割対象文字列
+///
+/// # 戻り値
+/// 分割結果ベクター（空文字・"total"除去済）
 async fn sep_frame_vec(text: &str) -> Vec<String> {
-    // Remove whitespace
-    let mut result = Vec::new();
-    let mut last = 0;
+    let mut result = Vec::new(); // 分割結果格納ベクター初期化
+    let mut last = 0; // 前回インデックス保持用
 
-    // Split to vector keeping the SEPERATORS
+    // セパレータ（英数字以外）で分割処理
     for (index, matched) in text.match_indices(|c: char| !(c.is_alphanumeric())) {
         if last != index {
-            result.push(text[last..index].to_string());
+            result.push(text[last..index].to_string()); // 文字列部分抽出
         }
-        result.push(matched.to_string());
-        last = index + matched.len();
+        result.push(matched.to_string()); // セパレータ抽出
+        last = index + matched.len(); // インデックス更新
     }
     if last < text.len() {
-        result.push(text[last..].to_string());
+        result.push(text[last..].to_string()); // 残余部分抽出
     }
 
-    // Removes empty entries and "total"
+    // 空文字および "total" 削除処理（複数エントリの場合）
     if result.len() > 1 {
         'outer: loop {
-            let cur_it_len = result.len();
+            let cur_it_len = result.len(); // 現在長さ保持
 
-            //println!("Before loop: {:?}, cur_it_len {}", result, result.len());
+            // 各エントリ検査ループ
             for r in 0..result.len() - 1 {
-                //println!("In loop: {:?}, index {}, len {}", result, r, result.len());
                 if result[r].to_lowercase() == "total" || result[r].is_empty() || result[r] == " " {
-                    //println!("Index: {}, Removing total empty space. {:?}, len {}", r, result, result.len());
-                    result.remove(r);
-                    break;
+                    result.remove(r); // 不要項目削除
+                    break; // 削除後ループ再開
                 }
             }
 
             if cur_it_len == result.len() {
-                break 'outer;
+                break 'outer; // 安定状態判定
             }
         }
     }
-    result
+    result // 分割結果返却
 }
 
-/// Display visually, a move's frame meter.
+/// ムーブのフレームメーターを視覚表示するコマンド処理
+///
+/// # 引数
+/// * `ctx` - コマンド実行コンテキスト
+/// * `character` - キャラクター名またはニックネーム
+/// * `character_move` - ムーブ名・入力またはエイリアス
+///
+/// # 戻り値
+/// 処理結果 `Result<(), Error>`
 #[poise::command(prefix_command, slash_command)]
 pub async fn meter(
-    ctx: Context<'_>,
+    ctx: Context<'_>, // コマンドコンテキスト
     #[min_length = 2]
     #[description = "Character name or nickname."]
-    character: String,
+    character: String, // キャラクター指定文字列
     #[min_length = 2]
     #[rename = "move"]
     #[description = "Move name, input or alias."]
-    character_move: String,
+    character_move: String, // ムーブ指定文字列
 ) -> Result<(), Error> {
     println!(
         "{}",
         ("Command Args: '".to_owned() + &character + ", " + &character_move + "'").purple()
-    );
+    ); // コマンド引数出力
 
     if (check::adaptive_check(ctx, true, true, true, true, true, false, false).await).is_err() {
-        return Ok(());
+        return Ok(()); // チェック失敗時早期返却
     }
 
-    // Finding character
-    // This will store the full character name in case user input was an alias
+    // キャラクター探索処理（エイリアス対応）
     let character_arg_altered = match find::find_character(&character).await {
-        Ok(character_arg_altered) => character_arg_altered,
+        Ok(character_arg_altered) => character_arg_altered, // キャラクター名称確定
         Err(err) => {
-            ctx.say(err.to_string()).await?;
-            println!("{}", ("Error: ".to_owned() + &err.to_string()).red());
-            return Ok(());
+            ctx.say(err.to_string()).await?; // エラーメッセージ送信
+            println!("{}", ("Error: ".to_owned() + &err.to_string()).red()); // エラー出力
+            return Ok(()); // エラー時早期返却
         }
     };
 
-    // Reading the character json
+    // キャラクターファイルパス生成
     let char_file_path =
-        "data/".to_owned() + &character_arg_altered + "/" + &character_arg_altered + ".json";
+        "data/".to_owned() + &character_arg_altered + "/" + &character_arg_altered + ".json"; // JSONファイルパス生成
     let char_file_data = fs::read_to_string(char_file_path)
-        .expect(&("\nFailed to read '".to_owned() + &character + ".json" + "' file."));
+        .expect(&("\nFailed to read '".to_owned() + &character + ".json" + "' file.")); // ファイル読み込み
 
-    // Deserializing from character json
-    let moves_info = serde_json::from_str::<Vec<MoveInfo>>(&char_file_data).unwrap();
+    // キャラクター情報デシリアライズ
+    let moves_info = serde_json::from_str::<Vec<MoveInfo>>(&char_file_data).unwrap(); // ムーブ情報抽出
 
     println!(
         "{}",
         ("Successfully read '".to_owned() + &character_arg_altered + ".json' file.").green()
-    );
+    ); // 成功出力
 
-    // Finding move index
+    // ムーブ探索処理（インデックス取得）
     let index =
         match find::find_move_index(&character_arg_altered, character_move, &moves_info).await {
-            Ok(index) => index,
+            Ok(index) => index, // ムーブインデックス確定
             Err(err) => {
                 ctx.say(err.to_string() + "\nView the moves of a character by executing `/moves`.")
-                    .await?;
-                println!("{}", ("Error: ".to_owned() + &err.to_string()).red());
-                return Ok(());
+                    .await?; // エラーメッセージ送信
+                println!("{}", ("Error: ".to_owned() + &err.to_string()).red()); // エラー出力
+                return Ok(()); // エラー時早期返却
             }
         };
 
-    // Reading images.json for this character
+    // 画像情報ファイル読み込み
     let image_links = fs::read_to_string(
         "data/".to_owned() + &character_arg_altered + "/images.json",
     )
     .expect(
         &("\nFailed to read 'data/".to_owned() + &character_arg_altered + "'/images.json' file."),
-    );
+    ); // 画像ファイル読み込み
 
-    // Deserializing images.json for this character
-    let image_links = serde_json::from_str::<Vec<ImageLinks>>(&image_links).unwrap();
-    let move_info = &moves_info[index];
-    let mut embed_image = String::new();
+    // 画像情報デシリアライズ
+    let image_links = serde_json::from_str::<Vec<ImageLinks>>(&image_links).unwrap(); // 画像リンク抽出
+    let move_info = &moves_info[index]; // 対象ムーブ情報取得
+    let mut embed_image = String::new(); // 埋め込み画像初期化
 
-    // Send move image
+    // ムーブ画像送信処理
     for img_links in image_links {
-        // Iterating through the image.json to find the move's hitbox links
+        // 画像リンク走査ループ
         if move_info.input == img_links.input {
+            // ヒット判定
             println!(
                 "{}",
                 ("Successfully read move '".to_owned()
@@ -299,53 +310,46 @@ pub async fn meter(
                     + &character_arg_altered
                     + ".json' file.")
                     .green()
-            );
+            ); // 成功出力
 
             if !img_links.move_img.is_empty() {
-                embed_image = img_links.move_img;
+                embed_image = img_links.move_img; // ムーブ画像設定
             } else {
-                embed_image = String::from(IMAGE_DEFAULT);
+                embed_image = String::from(IMAGE_DEFAULT); // デフォルト画像設定
             }
         }
     }
 
-    // Processing for startup frames
-    let mut meter_msg = String::from("`");
-    //let mut meter_msg = String::new();
-    meter_msg += &startup_frames(move_info).await;
-    meter_msg += &active_frames(move_info).await;
-    meter_msg += &recovery_frames(move_info).await;
-    meter_msg += "`";
-
-    let embed_title = "__**".to_owned()
-        + &character_arg_altered.replace('_', " ")
-        + " "
-        + &move_info.input
-        + " / "
-        + &move_info.name
-        + "**__";
+    // フレームメーター文字列生成処理
+    let mut meter_msg = String::from("`"); // バッククォート開始
+    meter_msg += &startup_frames(move_info).await; // 開始フレーム処理
+    meter_msg += &active_frames(move_info).await; // アクティブフレーム処理
+    meter_msg += &recovery_frames(move_info).await; // リカバリーフレーム処理
+    meter_msg += "`"; // バッククォート終了
+
+    let embed_title = "__**".to_owned() + &move_info.input + "**__"; // 埋め込みタイトル生成
 
     let embed_url =
-        "https://dustloop.com/w/GGST/".to_owned() + &character_arg_altered + "#Overview";
+        "https://dustloop.com/w/GGST/".to_owned() + &character_arg_altered + "#Overview"; // 埋め込みURL生成
 
     let embed = CreateEmbed::new()
-        .color(EMBED_COLOR)
-        .title(embed_title)
-        .url(embed_url)
+        .color(EMBED_COLOR) // 埋め込み色設定
+        .title(embed_title) // タイトル設定
+        .url(embed_url) // URL設定
         .fields(vec![
-            ("Startup", &move_info.startup.to_string(), true),
-            ("Active", &move_info.active.to_string(), true),
-            ("Recovery", &move_info.recovery.to_string(), true),
+            ("Startup", &move_info.startup.to_string(), true), // 開始フレームフィールド
+            ("Active", &move_info.active.to_string(), true),   // アクティブフレームフィールド
+            ("Recovery", &move_info.recovery.to_string(), true), // リカバリーフレームフィールド
         ])
-        .image(embed_image);
+        .image(embed_image); // 画像設定
 
     let embed2 = CreateEmbed::new()
-        .color(EMBED_COLOR)
-        .description(&meter_msg);
-
-    let vec_embeds = vec![embed, embed2];
-    let mut reply = poise::CreateReply::default();
-    reply.embeds.extend(vec_embeds);
-    ctx.send(reply).await?;
-    Ok(())
+        .color(EMBED_COLOR) // 埋め込み色設定
+        .description(&meter_msg); // 説明文設定
+
+    let vec_embeds = vec![embed, embed2]; // 埋め込みベクター作成
+    let mut reply = poise::CreateReply::default(); // 返信オブジェクト初期化
+    reply.embeds.extend(vec_embeds); // 埋め込み追加
+    ctx.send(reply).await?; // 返信送信
+    Ok(()) // 正常終了
 }
