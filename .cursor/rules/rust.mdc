---
description: rust関係のルール
globs: 
alwaysApply: false
---
## 主要原則
- 明確で簡潔、かつ慣用的なRustコードを正確な例と共に記述
- 非同期プログラミングパラダイムを効果的に使用。並行処理には`tokio`を活用
- モジュール性、クリーンなコード編成、効率的なリソース管理を優先
- 意図を伝える表現力豊かな変数名を使用（例：`is_ready`、`has_data`）
- Rustの命名規則に準拠。変数と関数にはsnake_case、型と構造体にはPascalCase
- コードの重複を回避。再利用可能なロジックをカプセル化するための関数とモジュールの使用
- 安全性、並行性、パフォーマンスを念頭に置いたコード作成。Rustの所有権と型システムの活用

## 非同期プログラミング
- 非同期タスクとI/Oの処理には`tokio`を非同期ランタイムとして使用
- `async fn`構文による非同期関数の実装
- タスクの生成と並行処理には`tokio::spawn`の活用
- 複数の非同期タスクとキャンセルの管理には`tokio::select!`を使用
- 構造化された並行性の重視。スコープ付きタスクとクリーンなキャンセルパスの優先
- タイムアウト、リトライ、バックオフ戦略の実装による堅牢な非同期操作

## チャネルと並行性
- 非同期のマルチプロデューサー・シングルコンシューマーチャネルには`tokio::sync::mpsc`を使用
- 複数のコンシューマーへのメッセージブロードキャストには`tokio::sync::broadcast`を使用
- タスク間の一回限りの通信には`tokio::sync::oneshot`の実装
- バックプレッシャーには有界チャネルを優先。容量制限の適切な処理
- タスク間での共有状態管理には`tokio::sync::Mutex`と`tokio::sync::RwLock`を使用。デッドロックの回避

## エラー処理と安全性
- RustのResultとOption型のエラー処理への活用
- 非同期関数でのエラー伝播には`?`演算子を使用
- より説明的なエラーには`thiserror`または`anyhow`を使用したカスタムエラー型の実装
- エラーとエッジケースの早期処理。適切な場所でのエラー返却
- `.await`の責任ある使用。コンテキスト切り替えの安全なポイントの確保

## テスト
- 非同期テストには`tokio::test`を使用した単体テストの記述
- 実際の遅延なしでの時間依存コードテストには`tokio::time::pause`を使用
- 非同期の振る舞いと並行性を検証するための統合テストの実装
- テストでの外部依存関係へのモックとフェイクの使用

## パフォーマンス最適化
- 非同期のオーバーヘッドの最小化。非同期が不要な場合は同期コードの使用
- 非同期関数内でのブロッキング操作の回避。必要に応じた専用ブロッキングスレッドへのオフロード
- 協調的マルチタスキングシナリオでは`tokio::task::yield_now`による制御の譲渡
- 非同期用のデータ構造とアルゴリズムの最適化。競合とロック期間の削減
- 効率的な時間ベースの操作には`tokio::time::sleep`と`tokio::time::interval`の使用

## 主要な規約
1. アプリケーションのモジュール化。ネットワーキング、データベース、ビジネスロジックなどの懸念事項の分離
2. 設定管理への環境変数の使用（例：`dotenv`クレート）
3. インラインコメントとRustdocによるコードの十分な文書化の確保

## 非同期エコシステム
- 非同期ランタイムとタスク管理には`tokio`の使用
- 非同期HTTP要求には`hyper`または`reqwest`の活用
- シリアライズ/デシリアライズには`serde`の使用
- 非同期データベース操作には`sqlx`または`tokio-postgres`の使用
- 非同期サポート付きのgRPCには`tonic`の活用

非同期パターン、ベストプラクティス、高度な機能に関する詳細情報はRustの非同期本と`tokio`のドキュメントを参照

# Your rule content

- You can @ files here
- You can use markdown but dont have to
